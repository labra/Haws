<!DOCTYPE html>
<html>
  	<head>
  	<title>Semantics of SHACL</title>
   	<meta charset='utf-8'>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common'
            async class='remove'></script>
    <script class='remove'>
	      var respecConfig = {
	          specStatus: "unofficial",
	          shortName:  "ldom-primer",
	          editors: [
	                {   name:       "Jose Emilio Labra Gayo",
	                    url:        "http://www.di.uniovi.es/~labra",
	                    company:    "University of Oviedo",
	                    companyURL: "http://www.uniovi.es/" }
	          ],
	          wg:           "RDF Data Shapes Working Group",
	          wgURI:        "https://www.w3.org/2014/data-shapes/wiki/Main_Page",
	          wgPublicList: "public-data-shapes",
	          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",
	      };
</script>
<style>
			.todo {
				color: red;
			}
		    pre {
				tab-size: 4;
		    }
			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
.comment {
        /* font-lock-comment-face */
        color: #b22222;
      }
      .constant {
        /* font-lock-constant-face */
        color: #008b8b;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #0000ff;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #a020f0;
      }
      .string {
        /* font-lock-string-face */
        color: #8b2252;
      }
      .type {
        /* font-lock-type-face */
        color: #228b22;
      }
      .example {
        display: inline-block;
      }
      .example.wrapper {
        background-color: #fff;
      }
      .example.wrapper pre {
        background-color: #fcfaee;
        margin-left: 0;
        line-height: 1.2;
      }
      .example.wrapper .fail {
        background-color: #fceefa
      }
      .verticalDivider {
        float: left;
        width: .5em;
        border:thin solid #fff; /* disappears without this */
      }
.highlight1     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 176, 0, .5); border-right: 5px solid rgba(176, 176, 0, .5); } /* font-weight: bold  ;  */
.highlight1.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
.highlight1.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
.lowlight1      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid transparent; border-right: 5px solid transparent;                     } /* font-weight: normal;  */
.lowlight1.top  {    margin-top: -5px;                      border-top: 5px solid transparent;                                                          } /* font-weight: normal;  */
.lowlight1.bot  { margin-bottom: -5px;                   border-bottom: 5px solid transparent;                                                          } /* font-weight: normal;  */
.highlight2     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 0, 176, .5); border-right: 5px solid rgba(176, 0, 176, .5); } /* font-weight: bold  ;  */
.highlight2.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
.highlight2.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
.lowlight2      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(127, 127, 127, .07); border-right: 5px solid rgba(127, 127, 127, .07);         } /* font-weight: normal;  */
.lowlight2.top  {    margin-top: -5px;                      border-top: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */
.lowlight2.bot  { margin-bottom: -5px;                   border-bottom: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */
.highlightBG1   { /* border: 5px solid transparent; */ background-color: #bb0; font-weight: bold; }
.lowlightBG1    { /* border: 5px solid transparent; */ font-weight: normal; }
.highlightBG2   { /* border: 5px solid transparent; */ background-color: #b00; font-weight: bold; }
.lowlightBG2    { /* border: 5px solid transparent; */ font-weight: normal; }
.new            { font-weight: bold; }
.errorSite      { color: red; }

</style>  		
 <script src="http://www.w3.org/2013/ShEx/demobits/jquery.min.js" type= "text/javascript"></script>
    <script type="text/javascript"><!--
function prepareHighlight (highlightables, onClass, offClass, slide) {
  if (slide === undefined)
    slide = $("body .namespace").last();
  $.each( highlightables, function( index, value ){
    var elts = slide.find( "."+value );
    elts
  	.mouseenter(function() {
  	    elts.removeClass(offClass).addClass(onClass);
  	})
  	.mouseleave(function() {
  	    elts.removeClass(onClass).addClass(offClass);
  	})
    .addClass(offClass);
  })
}
--> </script>
</head>
<body>
    
 <section id="abstract">
<p>
<p>SHACL(SHApes Checking Language) is an RDF vocabulary for describing RDF graph structures.
These graph structures are captured as <i>shapes</i>, which are expected to correspond to nodes in RDF graphs.
These shapes identify predicates and their associated cardinalities and datatypes.
</p>
<p>This document introduces the semantics of the SHACL core language features using inference rules.
</p>

<div class="todo">
<p>This document is a work in progress proposal based on the core language features. 
The SHACL language constructs have yet to be defined by the WG</p>
<p>This document just assumes that some node in an RDF graph 
 has been selected to check its shape in a schema. 
 The triggering selection mechanisms are not defined in this document</p>
</div>
</section>

<section id='sotd'>

</section>
    
<section id="introduction">
<h2>Introduction</h2>
<p>
This documents contains a formal semantic specification of SHACL.
The formal semantics is defined in terms of inference rules and axioms.

The semantics has been translated to Haskell to obtain an executable semantic prototype.
The source code is available <a href="https://github.com/labra/Haws/blob/master/papers/ldom.hs">here</a>.
</p>
</section>

<section id="FullSHACLSyntax">
<h2>Full SHACL syntax</h2>

<p>The full SHACL syntax can be defined as:

<p>A schema is a list of Labels associated with shapes

<pre>
Schema ::= Label Shape *           // Schema associates a Label with a Shape
</pre>

<p>The abstract syntax of shapes can be recursively defined as:</p>

<pre>
Shape ::= Empty                          // No constraint
        | BasicArc Cardinality           // Arc with predicate, value and cardinality
		| BasicArc "+"                   // 1 or more basic arcs
		| BasicArc "?"                   // 0 or 1 basic arcs
		| BasicArc "*"                   // 0 or more basic arcs
	    | And (Shape1,Shape2,...ShapeN)  // Matches if E and F match
	    | Or (Shape1, Shape2,...ShapeN)  // Matches if either E or F match
</pre>

<p>Basic arcs can be direct arcs or inverse arcs.</p>

<pre>	
BasicArc ::= Arc Predicate Value     // Direct arc
           | InvArc Predicate Value  // Inverse arc
</pre>

<p>Cardinality defines the minimum and maximum cardinality. 
   The maximum cardinality can be <code>unbounded</code></p>

<pre>
Cardinality ::= {Int,Int | unbounded}  // Min,Max-cardinality
</pre>

<p>Value specifies if an object matches 
 with a set of values <i>v1,...,vN</i>, 
 if it has a type identified by <i>URI</i> 
 or if it is an node that conforms with the shape identified by <i>Label</i>
<pre>
Value ::= ValueSet (v1 v2 ... vN) // Matches a set of values v1...vN
        | ValueType URI           // Matches if the value belongs to the type denoted by URI
        | ValueRef Label          // Matches if the value is a node that conforms with the shape identified by Label 
</pre>

<div class="todo">
 <p>Value should be extended to handle kinds like URI, BNode, Literal, 
    and language tagged literals</p> 
</div>

</section>
<section id="example">
<h2>Example</h2>

<div class="example wrapper">
	  
<pre class="schema turtle" style="float:left;">
<span class="comment"># shapes (Turtle)</span>
<span class="function-name">sh:IssueShape</span> <span class="keyword">a</span> <span class="type">ldom:</span><span class="constant">Shape</span> ;
    <span class="state      lowlight1 top"><span class="type">ldom:</span><span class="constant">property</span> [                                     </span>
    <span class="state      lowlight1    ">    <span class="type">ldom:</span><span class="constant">predicate</span> <span class="type">ex:</span><span class="constant">state</span> ;</span>
<div class="enumChoice collection">
 <span class="state      lowlight1    "><span class="type">ldom:</span><span class="constant">allowedValue</span> <span class="stateValue lowlight2 top bot">(<span class="type">ex:</span><span class="constant">unassigned</span> <span class="type">ex:</span><span class="constant">assigned</span>)</span> ; </span>
</div>
<div class="enumChoice objectlist">    <span class="state      lowlight1    ">    <span class="type">ldom:</span><span class="constant">allowedValue</span> <span class="stateValue lowlight2 top bot"><span class="type">ex:</span><span class="constant">unassigned</span> , <span class="type">ex:</span><span class="constant">assigned</span></span> ; </span>
</div>    <span class="state      lowlight1    ">    <span class="type">ldom:</span><span class="constant">minCount</span> 1 ; <span class="type">ldom:</span><span class="constant">maxCount</span> 1               </span>
    <span class="state      lowlight1 bot">] ;                                                 </span>
    <span class="reportedBy lowlight1 top"><span class="type">ldom:</span><span class="constant">property</span> [                                     </span>
    <span class="reportedBy lowlight1    ">    <span class="type">ldom:</span><span class="constant">predicate</span> <span class="type">ex:</span><span class="constant">reportedBy</span> ;                  </span>
    <span class="reportedBy lowlight1    ">    <span class="type">ldom:</span><span class="constant">valueShape</span> <span class="user lowlight2 top bot"><span class="function-name">sh:UserShape</span></span> ;                  </span>
    <span class="reportedBy lowlight1    ">    <span class="type">ldom:</span><span class="constant">minCount</span> 1 ; <span class="type">ldom:</span><span class="constant">maxCount</span> 1               </span>
    <span class="reportedBy lowlight1 bot">] <span class="keyword">.</span>                                                 </span>

<span class="user lowlight2 top bot"><span class="function-name">sh:UserShape</span></span> <span class="keyword">a</span> <span class="type">ldom:</span><span class="constant">Shape</span> ;
    <span class="name       lowlight1 top"><span class="type">ldom:</span><span class="constant">property</span> [                                     </span>
    <span class="name       lowlight1    ">    <span class="type">ldom:</span><span class="constant">predicate</span> <span class="type">foaf:</span><span class="constant">name</span> ;                      </span>
    <span class="name       lowlight1    ">    <span class="type">ldom:</span><span class="constant">valueType</span> <span class="string lowlight2 top bot"><span class="type">xsd:</span><span class="constant">string</span></span> ;                     </span>
    <span class="name       lowlight1    ">    <span class="type">ldom:</span><span class="constant">minCount</span> 1 ; <span class="type">ldom:</span><span class="constant">maxCount</span> 1               </span>
    <span class="name       lowlight1 bot">] ;                                                 </span>
    <span class="mbox       lowlight1 top"><span class="type">ldom:</span><span class="constant">property</span> [                                     </span>
    <span class="mbox       lowlight1    ">    <span class="type">ldom:</span><span class="constant">predicate</span> <span class="type">foaf:</span><span class="constant">mbox</span> ;                      </span>
    <span class="mbox       lowlight1    ">    <span class="type">ldom:</span><span class="constant">nodeType</span> <span class="IRI lowlight2 top bot"><span class="type">ldom:</span><span class="constant">IRI</span></span> ;                        </span>
    <span class="mbox       lowlight1    ">    <span class="oneOrMore lowlight2 top bot"><span class="type">ldom:</span><span class="constant">minCount</span> 1</span>                                 </span>
    <span class="mbox       lowlight1 bot">] <span class="keyword">.                                                 </span></span>
</pre>
</div>

<p>The example can be defined in the abstract syntax as:

<pre>
IssueShape 
 (And (Arc ex:state (ValueSet (ex:unasigned ex:asigned)) {1,1})
      (Arc ex:reportedBy (ValueRef sh:UserShape) {1,1})
 )

UserShape 
 (And (Arc foaf:name (ValueType xsd:string) {1,1})
       (Arc foaf:mbox (ValueType URI) {1,unbounded})
 )
</pre>
</section>

<section id="SimplificationSyntax">

<h2>Simplification rules</h2>

<p>
<pre>
basicArc+ = basicArc { 1,unbounded }
basicArc? = basicArc { 0,1 }
basicArc* = basicArc { 0,unbounded }

And(e1,e2,...eN) = And(e1,And(e2,...And(eN,Empty)))
Or(e1,e2,...eN) = Or(e1,Or(e2,...Or(eN,Empty)))
</pre>
</p>

</section>
		
<section id="AbstractSyntax">
<h2>Simple syntax</h2>
<p>The full SHACL simplified syntax can be defined as
<pre>
Shape ::= Empty                   // No constraint
       | BasicArc Cardinality     // Basic arc with cardinality
	   | And Shape Shape          // Matches if E and F match
	   | Or Shape Shape           // Matches if either E or F match
</pre>

</section>
		
<section id="AxiomaticSemantics">

<h2>Formal semantics</h2>

<section id="Formalism">
<h2>Description of the Formal Semantics</h2>
<p>The semantics of a Shape schema consist of a 
specification of what nodes in an RDF graph match a specific shape
with respect to that schema. 
The semantics is described formally. 
The formalism uses axioms and inference rules. 
Axioms are propositions that are provable unconditionally. 
An inference rule consists of one or more antecedents and exactly one consequent. 
An antecedent is either positive or negative. 
If all the positive antecedents of an inference rule are provable and none of the negative 
antecedents are provable, then the consequent of the inference rule is provable. </p>

<p>
The notation for inference rules separates the antecedents from the consequent 
by a horizontal line: 
the antecedents are above the line; 
the consequent is below the line. 
If an antecedent is of the form <i>not(p)</i>, 
then it is a negative antecedent; 
otherwise, it is a positive antecedent. </p>
<p>The formal semantics presented follows the same formalism as the one used for 
 <a href="http://relaxng.org/spec-20011203.html">RelaxNG</a>
</section>

<section id="Preliminaries">
<h2>Preliminaries</h2>

<section id="RDFGraphs">
<h2>RDF graphs</h2>
The natural semantics matches infers a typing for a resource in an RDF graph. 
We represent RDF graphs as sets of RDF triples, where an RDF triple is 
<i>(subject,predicate,object)</i>
such that 
<i>subject</i> is a <i>URI</i> or a <i>BNode</i>, 
<i>predicate</i> is a <i>URI</i> and 
<i>object</i> is a <i>URI</i>, <i>BNode</i> or <i>Literal</i>.
For our purposes, an RDF graph has the following operations:

<table>
<tr>
<td>{}</td><td>Empty graph</td>
</tr>
<tr>
<td>{<i>t</i>}</td>
<td>Singleton graph with triple t</td>
</tr>
<tr>
<td><i>addTriple(t,ts)</i></td>
<td>The set of triples that results of adding triple <i>t</i> to 
    the set of triples <i>ts</i></td>
</tr>
<tr>
<td><i>removeTriple(g)</i></td>
<td>A pair <i>(t,g')</i> where <i>t</i> is a triple removed 
   from the set of triples <i>g</i> and <i>g'</i> is the remaining triples</td>
</tr>
<tr>
<td>g1 union g2</td>
<td>Union of graphs <i>g1</i> and <i>g2</i>
</tr>
<tr>
<td>g1 intersection g2</td>
<td>Intersection of graphs <i>g1</i> and <i>g2</i>
</tr>
<tr>
<td>g.triplesAround(node)</td>
<td>Selects the triples that contain <i>node</i> as subject or as object in graph <i>g</i></td>
</tr>
</table>

</section>

<section id="Typings">
<h2>Typings</h2>
<p>The semantics of SHACL consists of assigning typings to nodes in an RDF graph. 
A typing is a map from RDF nodes (iri's or bNodes) to sets of labels in a Schema.
<p> 
We define the following operations on shape typings:

<table>
<tr>
<td>{}</td><td>empty shape typing</td>
</tr>
<tr>
<td><i>addType(node,label,typing)</i></td>
<td>the result of associating type <i>label</i> 
    to <i>node</i> in <i>typing</i></td>
</tr>
<tr>
<td><i>combineTypings(t1, t2)</i></td>
<td>combination of typings <i>t1</i> and <i>t2</i></td>
</tr>
<tr>
<td><i>contains(t,node,label)</i></td>
<td>returns true if the typing <i>t</i> asserts that <i>node</i> has shape <i>label</i></td>
</tr>

</table>
</section>
		 
<section id="Context">
<h2>Context</h2>
<p>The shape schema validator acts in a context.
A context is a tuple <i>(s, g, t)</i> where
 <i>s</i> is a Schema, 
 <i>g</i> is an RDF Graph and
 <i>t</i> is a Typing. 
</p> 

We define the following operations on contexts:

<table>
<tr>
<td><i>ctx.typing</i></td><td>returns current typing in <i>ctx</i></td>
</tr>
<tr>
<td><i>ctx { node -> label }</i></td>
<td>Given a context with typing <t> returns the same context 
    where the typing is <i>addType(node,label,typing)</i></td>
</tr>
</table>

</section>
</section>

		 
<section id="MatchNode">
<h2>matchNode</h2>

<i>ctx |- matchNode(node, label)</i> checks if a <i>node</i> conforms
 with the shape associated with <i>label</i> in context <i>ctx</i>. 
 If it conforms, it returns <i>(t,cs,rs)</i> where 
<i>t</i> is a typing, 
<i>cs</i> is a set of checked triples, 
<i>rs</i> is a set of remaining triples.

<table class="rule">
<tr>
<td rowspan="2">matchNode</td>
<td class="up">
 ctx.schema(label) = shape &nbsp;&nbsp;&nbsp; 
 ctx.graph.triplesAround(node) = ts &nbsp;&nbsp;&nbsp;
 ctx { node -> label } |- matchShape(ts, shape) = (t,cs,rs)
</td>
</tr>
<tr><td>ctx |- matchNode(node,label) = (t,cs,rs)</td></tr>
</table>
</section>


<section id="MatchShape">
<h2>matchShape</h2>
<p>
<i>ctx |- matchShape(triples, shape)</i> checks if a set of triples <i>triples</i> conforms
 with <i>shape</i> in context <i>ctx</i>. 
 If it conforms, it returns <i>(t,cs,rs)</i> where 
<i>t</i> is a typing, 
<i>cs</i> is a set of checked triples, 
<i>rs</i> is a set of remaining triples.
</p>

<p>The empty shape matches any set of triples without any constraint.</p>
<table class="rule">
<tr>
<td rowspan="2">Empty</td>
<td class="up">
 &nbsp;
</td>
</tr>
<tr><td>ctx |- matchShape(ts,Empty) = (ctx.typing,{},ts)</td></tr>
</table>

<p>We distinguish 6 cases for basic arcs depending on the cardinality. </p>

<ul>

<li>
<p>When the cardinality is {0,unbounded} 
 and there is no arc that matches it matches the set of triples without 
 consuming any triple</p>
<table class="rule">
<tr>
<td rowspan="2">BasicArc_unbounded2</td>
<td class="up">
 ctx |- noMatchAny(ts,basicArc) &nbsp;&nbsp;&nbsp;
</td>
</tr>
<tr><td>ctx |- matchShape(ts,basicArc {0,unbounded}) = (ctx.typing,{},ts)</td></tr>
</table>

<li>
<p>When the cardinality is {0,unbounded} 
 and there is some arc that matches it consumes it</p>
<table class="rule">
<tr>
<td rowspan="2">BasicArc_unbounded2</td>
<td class="up">
 remove(ts) = (t,ts') &nbsp;&nbsp;&nbsp;
 ctx |- matchBasicArc(t,basicArc) = t1 &nbsp;&nbsp;&nbsp;
 ctx |- matchBasicArc(ts',basicArc {0,unbounded}) = (t2,cs,rs) 
</td>
</tr>
<tr><td>ctx |- matchShape(ts,basicArc {0,unbounded}) = (combineTypings(t1,t2),addTriple(t,cs),rs)</td></tr>
</table>

<li>
<p>When the cardinality is <i>{m,unbounded}</i> for <i>m > 0</i> it matches if
 there is one triple that matches and if the rest of triples matches 
 with a cardinality of <i>{m - 1, unbounded}</i></p>
<p>Notice that it only matches if there is at least one triple</p>

<table class="rule">
<tr>
<td rowspan="2">BasicArc_unbounded3</td>
<td class="up">
m > 0 &nbsp;&nbsp;&nbsp;
removeTriple(ts) = (t,ts') &nbsp;&nbsp;&nbsp;
ctx |- matchArc(t,basicArc) = t1 &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts',basicArc {m - 1,unbounded}) = (t2,cs,rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, basicArc {m,unbounded}) = (combineTypings(t1,t2),addTriple(t,cs),rs)</td></tr>
</table>

<li>

<p>When the cardinality is <i>{0, n}</i> for <i>n >= 0</i> it can match if there 
is not triple that matches or if there 
is one triple that matches and the rest of triples matches with a cardinality of <i>{0, n-1}</i></p>

<table class="rule">
<tr>
<td rowspan="2">BasicArc_bounded1</td>
<td class="up">
n >= 0 &nbsp;&nbsp;&nbsp;
ctx |- noMatchAny(ts,basicArc)) 
</td>
</tr>
<tr><td>ctx |- matchShape(ts, basicArc {0, n}) = (ctx.typing,{},ts)</td></tr>
</table>

<li> 
<table class="rule">
<tr>
<td rowspan="2">BasicArc_bounded2</td>
<td class="up">
n > 0 &nbsp;&nbsp;&nbsp;
removeTriple(ts) = (t,ts') &nbsp;&nbsp;&nbsp;
matchArc(t,basicArc) = t1  &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts', basicArc {0, n - 1}) = (t2,cs,rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, basicArc {0, n}) = (combineTypings(t1,t2), addTriple(t,cs), rs)</td></tr>
</table>

<li>
<p>If the cardinality if <i>{m, n}</i> it matches if there is one triple that matches 
 and if the rest of triples match with the cardinality <i>{m - 1, n - 1}</i></p>
 
<table class="rule">
<tr>
<td rowspan="2">BasicArc_bounded3</td>
<td class="up">
m > 0, n >= m &nbsp;&nbsp;&nbsp;
removeTriple(ts) = (t,ts') &nbsp;&nbsp;&nbsp;
matchBasicArc(t, basicArc) = t1  &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts', basicArc {m-1, n-1} ) = (t2, cs, rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, basicArc {m, n}) = (combineTypings(t1,t2), addTriple(t,cs), rs)</td></tr>
</table>

</ul>

<p>If the shape is a conjunction it matches if it matches the first element and 
   then, the second with the remaining triples</p>

<table class="rule">
<tr>
<td rowspan="2">And</td>
<td class="up">
ctx |- matchShape(ts, e1) = (t1, cs1, rs1) &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts, e2) = (t2, cs2, rs2)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, And(e1, e2) = (combineTypings(t1,t2), cs1 union cs2, rs1 intersection rs2)</td></tr>
</table>

<p>If the shape is a disjunction it matches if either the first element matches or the second one does</p>

<table class="rule">
<tr>
<td rowspan="2">Or_1</td>
<td class="up">
ctx |- matchShape(ts, e1) = (t, cs, rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Or(e1,e2) = (t, cs, rs)</td></tr>
</table>

<table class="rule">
<tr>
<td rowspan="2">Or_2</td>
<td class="up">
ctx |- matchShape(ts, e2) = (t, cs, rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Or(e1,e2) = (t, cs, rs)</td></tr>
</table>

</section>

<section id="MatchBasicArc">
<h2>matchBasicArc</h2>
<p>This section covers how to match a basic Arc:
<i>ctx|-matchBasicArc(triple,basicArc)</i>. 
<p> There are two cases: direct arcs match the value with the object of the triple 
  while inverse arcs match the value with the subject the triple</p>

<table class="rule">
<tr>
<td rowspan="2">ObjectArc</td>
<td class="up">
ctx |- matchValue(o,v) = t
</td>
</tr>
<tr><td>ctx |- matchBasicArc(&lt;s,p,o&gt;, Arc p v) = t</td></tr>
</table>

<table class="rule">
<tr>
<td rowspan="2">SubjectArc</td>
<td class="up">
ctx |- matchValue(s,v) = t
</td>
</tr>
<tr><td>ctx |- matchBasicArc(&lt;s,p,o&gt;, InvArc p v) = t</td></tr>
</table>

</section>

<section id="MatchValue">
<h2>matchValue</h2>

<table class="rule">
<tr>
<td rowspan="2">valueSet</td>
<td class="up">
x &in; set
</td>
</tr>
<tr><td>ctx |- matchValue(x, ValueSet(set)) = ctx.typing</td></tr>
</table>

<div class="todo">
<p><i>noValueType</i> needs more work to handle different possibilities</p>
</div>

<table class="rule">
<tr>
<td rowspan="2">valueType</td>
<td class="up">
hastype(x,t)
</td>
</tr>
<tr><td>ctx |- matchValue(x, ValueType(t)) = ctx.typing</td></tr>
</table>

<p>ValueRef handles references to shapes. There are two cases, 
  the first initial case, when the context already contains the declaration
  that <i>x</i> has shape <i>label</i> just returns the current typing.</p>
  
<table class="rule">
<tr>
<td rowspan="2">valueRef_1</td>
<td class="up">
 contains(ctx.typing, x, label)
</td>
</tr>
<tr><td>ctx |- matchValue(x, ValueRef(label)) = ctx.typing</td></tr>
</table>

<p>The second case, when the context does not contain the declaration that <i>x</i> has the shape <i>label</i>
 is solved by trying to match <i>x</i> with shape <i>label</i> in the graph.</p>
 
<table class="rule">
<tr>
<td rowspan="2">valueRef_2</td>
<td class="up">
not(contains(ctx, x, label)) &nbsp; &nbsp; &nbsp;
ctx |- matchNode(x,v) = (t,_,_)
</td>
</tr>
<tr><td>ctx |- matchValue(x, ValueRef(label)) = t</td></tr>
</table>

</section>

<section id="noMatchAny">
<h2>noMatchAny</h2>
<p><i>noMatchArcAny</i> takes a set of triples and a basic arc and checks that there is no
 triple that matches the basic arc
</p>
 
<p>It has two possibilities. 

<table class="rule">
<tr>
<td rowspan="2">noMatchAny_1</td>
<td class="up">
 &nbsp; 
</td>
</tr>
<tr><td>ctx |- noMatchAny({}, basicArc)</td></tr>
</table>
 
<table class="rule">
<tr>
<td rowspan="2">noMatchAny_2</td>
<td class="up">
removeTriple(ts) = (t,ts') &nbsp;&nbsp;&nbsp;
ctx |- noMatchBasicArc(t,basicArc) &nbsp;&nbsp;&nbsp;
ctx |- noMatchAny(ts',basicArc)
</td>
</tr>
<tr><td>ctx |- noMatchAny(ts, basicArc)</td></tr>
</table>

</section> <!-- noMatchAny -->


<section id="noMatchBasicArc">
<h2>noMatchBasicArc</h2>
<p><i>noMatchBasicArc</i> 
</p>

<p>If the predicates are different, then it succeeds

<table class="rule">
<tr>
<td rowspan="2">noMatchBasicArc_1</td>
<td class="up">
p &ne; p'
</td>
</tr>
<tr><td>ctx |- noMatchBasicArc(&lt;s,p,o&gt;, Arc p' v)</td></tr>
</table>

<p>If the predicates are the same it succeeds if the value doesn't match. There are two cases 
 depending on direct/inverse arcs 
 
<table class="rule">
<tr>
<td rowspan="2">noMatchSubjectArc</td>
<td class="up">
ctx |- noMatchValue(o,v)
</td>
</tr>
<tr><td>ctx |- noMatchBasicArc(&lt;s,p,o&gt;, Arc p v)</td></tr>
</table>

<table class="rule">
<tr>
<td rowspan="2">noMatchObjectArc</td>
<td class="up">
ctx |- noMatchValue(s,v)
</td>
</tr>
<tr><td>ctx |- noMatchBasicArc(&lt;s,p,o&gt;, InvArc p v)</td></tr>
</table>
 
</section> <!-- noMatchBasicArc -->

<section id="noMatchValue">

<h2>noMatchValue</h2>
<p>It succeeds if the value doesn't match with the node.

<table class="rule">
<tr>
<td rowspan="2">noValueSet</td>
<td class="up">
x &notin; set
</td>
</tr>
<tr><td>ctx |- matchValue(x, ValueSet(set))</td></tr>
</table>

<div class="todo">
<p><i>noValueType</i> needs more work to handle different possibilities</p>
</div>
<table class="rule">
<tr>
<td rowspan="2">noValueType</td>
<td class="up">
hasNoType(x,t)
</td>
</tr>
<tr><td>ctx |- matchValue(x, ValueType(t))</td></tr>
</table>

<p><i>noValueRef</i> succeeds if the the system can not 
  determine that the node <i>x</i> has shape <i>label</i>.
  
<table class="rule">
<tr>
<td rowspan="2">valueRef_1</td>
<td class="up">
 ctx |- matchValue(x, ValueRef(label)) = ctx.typing &nbsp;&nbsp;&nbsp; 
 notContains(ctx.typing, x, label)
</td>
</tr>
<tr><td>ctx |- noMatchValue(x, ValueRef(label))</td></tr>
</table>

</section> <!-- noMatchValue -->

</section> <!-- AxiomaticSemantics -->
		
<section id="Extension">
<h2>Extended features</h2>
<p>The core SHACL language can be extended with the following constructs:

<pre>
Shape ::= Not Shape                // Matches if the shape does not match
	    | Close Shape              // Matches if it matches the shape and there are no remaining triples
		| Xor Shape Shape          // Matches if either the first shape or the second match, but not both
</pre>

<p>The axiomatic definition of these constructs are:

<p>If the shape is a negation of a shape it matches if the shape does not match</p>

<table class="rule">
<tr>
<td rowspan="2">Not</td>
<td class="up">
ctx |- not(matchShape(ts,e))
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Not(e)) = (t, ts, {})</td></tr>
</table>

<p>A set of triples matches a closed shape if the set of triples matches the shape
 and there are no remaining triples</p>

<table class="rule">
<tr>
<td rowspan="2">Close</td>
<td class="up">
ctx |- matchShape(ts,e) = (t,cs,{})
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Closed(e)) = (t, cs, {})</td></tr>
</table>

<p>The XOr construct is defined in terms of negation as:</p>

<pre>
Xor(e1,e2) = Or(And(e1,not(e2)),And(e2,not(e2)))
</pre>

</section>
<section class='appendix'>
<h2>Acknowledgements</h2>
<p>
We would like to acknowledge the contributions of 
 Peter F. Patel-Schneider, Eric Prud'hommeaux, Iovka Boneva 
 and the other members of the W3c Data Shapes Working group.
</p>
</section>

<section id='tof'></section>    		
</body>
</html>