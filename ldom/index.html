<!DOCTYPE html>
<html>
  	<head>
  	<title>Semantics of LDOM</title>
   	<meta charset='utf-8'>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common'
            async class='remove'></script>
    <script class='remove'>
	      var respecConfig = {
	          specStatus: "unofficial",
	          shortName:  "ldom-primer",
	          editors: [
	                {   name:       "Jose Emilio Labra Gayo",
	                    url:        "http://www.di.uniovi.es/~labra",
	                    company:    "University of Oviedo",
	                    companyURL: "http://www.uniovi.es/" }
	          ],
	          wg:           "RDF Data Shapes Working Group",
	          wgURI:        "https://www.w3.org/2014/data-shapes/wiki/Main_Page",
	          wgPublicList: "public-data-shapes",
	          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",
	      };
	    </script>
		<style>
			.todo {
				color: red;
			}
		    pre {
				tab-size: 4;
		    }
			th {
				text-align: left;
			}
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
		</style>  		
  	</head>
  	<body>
    
 <section id="abstract">
<p>
<p>LDOM (Lasagna Dumplings and Ostrich Meatballs) is an RDF vocabulary for describing RDF graph structures.
These graph structures are captured as <i>shapes</i>, which are expected to correspond to nodes in RDF graphs.
These shapes identify predicates and their associated cardinalities and datatypes.
</p>
<p>This document introduces the semantics of LDOM using inference rules.
</p>

<div class="todo">
<p>This document is a work in progress proposal based on the core language features. 
The LDOM language constructs have yet to be defined by the WG</p>
</div>
</section>

<section id='sotd'>

</section>
    
<section id="introduction">
<h2>Introduction</h2>
<p>
This documents contains a formal semantic specification of LDOM.
The formal semantics is defined in terms of inference rules and axioms.

The semantics has been translated to Haskell to obtain an executable semantic prototype.
</p>
</section>

<section id="FullLDOMSyntax">
<h2>Full LDOM syntax</h2>

<p>The full LDOM syntax can be defined as:

<pre>
Schema ::= (Label { Shape })*                // A schema contains a map from Labels to Shapes

Shape ::= Empty                              // No constraint
       | Arc Predicate Value Cardinality     // Arc with predicate, value and cardinality
	   | InvArc Predicate Value Cardinality  // Inverse arc
	   | And Shape Shape                     // Matches if E and F match
	   | Or Shape Shape                      // Matches if either E or F match
	   | Not Shape                           // Matches if E does not match
	   | Close Shape                         // Matches if it matches E and there is no remaining triple
	
Cardinality ::= {Int,Int}                 // Min,Max-cardinality
                            
Value ::= ValueSet (O1 O2 ... On)         // Matches a set of values O1...On
        | ValueType URI                   // Matches if the value belongs to the type denoted by URI
        | ValueRef Label                  // Matches if the value is a node that conforms with the shape identified by Label 
</pre>
</section>

<section id="SimplificationSyntax">
<h2>Simplification rules</h2>

<p>
<pre>
Xor(e1,e2) = Or(And(e1,not(e2)),And(e2,not(e2)))
And(e1,e2,...eN) = And(e1,And(e2,...And(eN,Empty)))
Or(e1,e2,...eN) = Or(e1,Or(e2,...Or(eN,Empty)))
</pre>
</p>

</section>
		
<section id="AbstractSyntax">
<h2>Simple syntax</h2>
<p>The LDOM simplified syntax can be defined as
<pre>
Schema ::= (Label { Shape })*     // A schema contains a map from Labels to Shapes

Shape ::= Empty                   // No constraint
       | BasicArc Cardinality     // Arc with predicate, value and cardinality
	   | And Shape Shape          // Matches if E and F match
	   | Or Shape Shape           // Matches if either E or F match
	   | Not Shape                // Matches if E does not match
	   | Close Shape              // Matches if it matches E and there is no remaining triple
	
Cardinality ::= {Int,Int}         // Min,Max-cardinality
                            
BasicArc ::= Arc Predicate Value     // Direct arc
           | InvArc Predicate Value  // Inverse arc

Value ::= ValueSet (O1 O2 ... On) // Matches a set of values O1...On
        | ValueType URI           // Matches if the value belongs to the type denoted by URI
        | ValueRef Label          // Matches if the value is a node that conforms with the shape identified by Label 

</pre>
</section>
		
<section id="NaturalSemantics">
<h2>Natural semantics</h2>
<section id="Formalism">
<h2>Description of the Formal Semantics</h2>
<p>The semantics of a Shape schema consist of a specification of what nodes in an RDF graph match a specific shape
 with respect to that schema. 
The semantics is described formally. 
The formalism uses axioms and inference rules. 
Axioms are propositions that are provable unconditionally. 
An inference rule consists of one or more antecedents and exactly one consequent. 
An antecedent is either positive or negative. 
If all the positive antecedents of an inference rule are provable and none of the negative 
antecedents are provable, then the consequent of the inference rule is provable. </p>

<p>
The notation for inference rules separates the antecedents from the consequent 
by a horizontal line: 
the antecedents are above the line; 
the consequent is below the line. 
If an antecedent is of the form not(p), then it is a negative antecedent; 
otherwise, it is a positive antecedent. </p>

</section>

<section id="Preliminaries">
<h2>Preliminaries</h2>

<section id="RDFGraphs">
<h2>RDF graphs</h2>
The natural semantics matches infers a typing for a resource in an RDF graph. 
We represent RDF graphs as sets of RDF triples, where an RDF triple is 
<i>(subject,predicate,object)</i>
such that 
<i>subject</i> is a <i>URI</i> or a <i>BNode</i>, 
<i>predicate</i> is a <i>URI</i> and 
<i>object</i> is a <i>URI</i>, <i>BNode</i> or <i>Literal</i>.
For our purposes, an RDF graph has the following operations:

<table>
<tr>
<td>{}</td><td>Empty graph</td>
</tr>
<tr>
<td>{<i>t</i>}</td>
<td>Singleton graph with triple t</td>
</tr>
<tr>
<td><i>t :: g</i></td>
<td>The graph that results of adding triple <i>t</i> to graph <i>g</i></td>
</tr>
<tr>
<td>g1 union g2</td>
<td>Union of graphs <i>g1</i> and <i>g2</i>
</tr>
<tr>
<td>g.triplesAround(node)</td>
<td>Selects the triples that contain <i>node</i> as subject or as object in graph <i>g</i></td>
</tr>
</table>

</section>

<section id="Typings">
<h2>Typings</h2>
The semantics of LDOM consits of assigning typings to nodes in an RDF graph. 
A typing is a map from RDF nodes (iri's or bNodes) to sets of labels in a Schema. 
We define the following operations on shape typings:

<table>
<tr>
<td>{}</td><td>empty shape typing</td>
</tr>
<tr>
<td><i>iri -> label :: typing</i></td>
<td>the result of assigning <i>iri</i> to <i>label</i> in <i>typing</i></td>
</tr>
<tr>
<td><i>t1</i> ++ <i>t2</i></td>
<td>combination of typings <i>t1</i> and <i>t2</i></td>
</tr>

</table>
</section>
		 
<section id="Context">
<h2>Context</h2>
<p>The shape schema validator acts in a context.
A context is a tuple <i>(s, g, t)</i> where
 <i>s</i> is a Schema, 
 <i>g</i> is an RDF Graph and
 <i>t</i> is a Typing. 
</p> 
</section>
		 
<section id="MatchNode">
<h2>Match node</h2>

<i>ctx |- matchNode(node, label)</i> checks if a <i>node</i> conforms
 with the shape associated with <i>label</i> in context <i>ctx</i>. 
 If it conforms, it returns <i>(t,cs,rs)</i> where 
<i>t</i> is a typing, 
<i>cs</i> is a set of checked triples, 
<i>rs</i> is a set of remaining triples.

<table class="rule">
<tr>
<td rowspan="2">matchNode</td>
<td class="up">
 ctx.schema(label) = shape &nbsp;&nbsp;&nbsp; 
 ctx.graph.triplesAround(node) = ts &nbsp;&nbsp;&nbsp;
 ctx { node -> label } |- matchShape(ts, shape) = (t,cs,rs)
</td>
</tr>
<tr><td>ctx |- matchNode(node,label) = (t,cs,rs)</td></tr>
</table>
</section>


<section id="MatchShape">
<h2>Match Shape</h2>

<i>ctx |- matchShape(triples, shape)</i> checks if a set of triples <i>triples</i> conforms
 with <i>shape</i> in context <i>ctx</i>. 
 If it conforms, it returns <i>(t,cs,rs)</i> where 
<i>t</i> is a typing, 
<i>cs</i> is a set of checked triples, 
<i>rs</i> is a set of remaining triples.

<p>The empty shape matches any set of triples without any constraint.</p>
<table class="rule">
<tr>
<td rowspan="2">Empty</td>
<td class="up">
 &nbsp;
</td>
</tr>
<tr><td>ctx |- matchShape(ts,Empty) = (ctx.typing,{},ts)</td></tr>
</table>

<p>We distinguish 5 cases for basic arc depending on the cardinality. 

<ol>
<li>When the cardinality is {0,unbounded} 
 it matches any set of triples:</p>
<table class="rule">
<tr>
<td rowspan="2">BasicArc_unbounded1</td>
<td class="up">
  &nbsp;
</td>
</tr>
<tr><td>ctx |- matchShape(ts,basicArc {0,unbounded}) = (ctx.typing,{},ts)</td></tr>
</table>

<li>When the cardinality is <i>{m,unbounded}</i> for <i>m > 0</i> it matches if
 there is one triple that matches and if the rest of triples matches 
 with a cardinality of <i>{m - 1, unbounded}</i>

<table class="rule">
<tr>
<td rowspan="2">BasicArc_unbounded2</td>
<td class="up">
m > 0 &nbsp;&nbsp;&nbsp;
ctx |- matchArc(t,basicArc) = t1 &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts,basicArc {m - 1,unbounded}) = (t2,cs,rs)
</td>
</tr>
<tr><td>ctx |- matchShape(t:ts, basicArc {m,unbounded}) = (t1 ++ t2,t:cs,rs)</td></tr>
</table>

<li>When the cardinality is <i>{0, n}</i> for <i>n >= 0</i> it can match if there 
is not triple that matches or if there 
is one triple that matches and the rest of triples matches with a cardinality of <i>{0, n-1}</i>

<table class="rule">
<tr>
<td rowspan="2">BasicArc_bounded1</td>
<td class="up">
n >= 0 &nbsp;&nbsp;&nbsp;
ctx |- not (matchArcs(ts,p,v)) 
</td>
</tr>
<tr><td>ctx |- matchShape(ts, BasicArc {0, n}) = (ctx.typing,{},ts)</td></tr>
</table>

<li>
<table class="rule">
<tr>
<td rowspan="2">BasicArc_bounded2</td>
<td class="up">
n >= 0 &nbsp;&nbsp;&nbsp;
matchArc(t,basicArc) = t1  &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts,basicArc {0, n - 1}) = (t2,cs,rs)
</td>
</tr>
<tr><td>ctx |- matchShape(t::ts, basicArc {0, n}) = (t1 ++ t2, t::cs, rs)</td></tr>
</table>

<li>
If the cardinality if <i>{m, n}</i> it matches if there is one triple that matches 
 and if the rest of triples match with the cardinality <i>{m - 1, n - 1}</i></p>
 
<table class="rule">
<tr>
<td rowspan="2">BasicArc_bounded3</td>
<td class="up">
m > 0, n >= m &nbsp;&nbsp;&nbsp;
matchBasicArc(t, basicArc) = t1  &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts, basicArc {m-1, n-1} ) = (t2, cs, rs)
</td>
</tr>
<tr><td>ctx |- matchShape(t::ts, basicArc {m, n}) = (t1 ++ t2, t::cs, rs)</td></tr>
</table>

</ul>

<p>If the shape is a conjunction it matches if it matches the first element and 
   then, the second with the remaining triples</p>

<table class="rule">
<tr>
<td rowspan="2">And</td>
<td class="up">
ctx |- matchShape(ts, e1) = (t1, cs1, rs) &nbsp;&nbsp;&nbsp;
ctx |- matchShape(rs, e2) = (t2, cs2, rs')
</td>
</tr>
<tr><td>ctx |- matchShape(ts, And(e1, e2) = (t1 ++ t2, cs1 ++ cs2, rs')</td></tr>
</table>

<p>If the shape is a disjunction it matches if either the first element matches or the second one does</p>

<table class="rule">
<tr>
<td rowspan="2">Or_1</td>
<td class="up">
ctx |- matchShape(ts, e1) = (t, cs, rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Or(e1,e2) = (t, cs, rs)</td></tr>
</table>

<table class="rule">
<tr>
<td rowspan="2">Or_2</td>
<td class="up">
ctx |- matchShape(ts, e2) = (t, cs, rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Or(e1,e2) = (t, cs, rs)</td></tr>
</table>

<p>If the shape is a negation of a shape it matches if the shape does not match</p>

<table class="rule">
<tr>
<td rowspan="2">Not</td>
<td class="up">
ctx |- no(matchShape(ts,e))
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Not(e)) = (t, ts, {})</td></tr>
</table>

<p>A set of triples matches a closed shape if the set of triples matches the shape
 and there are no remaining triples</p>

<table class="rule">
<tr>
<td rowspan="2">Close</td>
<td class="up">
ctx |- matchShape(ts,e) = (t,cs,{})
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Closed(e)) = (t, cs, {})</td></tr>
</table>

</section>

<section id="MatchBasicArc">
<h2>Match BasicArc</h2>
<p>ctx|-matchBasicArc(triple,basicArc</p>

<table class="rule">
<tr>
<td rowspan="2">BasicArc</td>
<td class="up">
ctx |- matchValueObject(o,v) = t
</td>
</tr>
<tr><td>ctx |- matchBasicArc(ts, <s,p,o>, Arc p v) = t</td></tr>
</table>

<table class="rule">
<tr>
<td rowspan="2">BasicArc</td>
<td class="up">
ctx |- matchValueSubject(s,v) = t
</td>
</tr>
<tr><td>ctx |- matchBasicArc(ts, <s,p,o>, InvArc p v) = t</td></tr>
</table>

</section>

<section id="MatchValueObject">
<h2>Match value object</h2>

<table class="rule">
<tr>
<td rowspan="2">valueObjectSet</td>
<td class="up">
o in set
</td>
</tr>
<tr><td>ctx |- matchValueObjectSet(o, ValueSet(set)) = ctx.typing</td></tr>
</table>

<table class="rule">
<tr>
<td rowspan="2">valueObjectType</td>
<td class="up">
o hastype t
</td>
</tr>
<tr><td>ctx |- matchValueObjectType(o, ValueType(t)) = ctx.typing</td></tr>
</table>

<table class="rule">
<tr>
<td rowspan="2">valueObjectRef</td>
<td class="up">
ctx |- matchNode(o,v) = (t,_,_)
</td>
</tr>
<tr><td>ctx |- matchValueObject(o, ValueRef(label)) = t</td></tr>
</table>

</section>

<section id="MatchValueSubject">
<h2>Match value subject</h2>
</section>
		 
</section>
		
<section class='appendix'>
<h2>Acknowledgements</h2>
<p>
We would like to acknowledge the contributions of ...
</p>
</section>

<section id='tof'></section>    		
</body>
</html>